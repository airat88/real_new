/* ============================================
   PDF EXPORT - Using pdfmake for Unicode support
   Supports Cyrillic (Russian) and Greek
   ============================================ */

const PDFExport = {
    // Translations for 3 languages
    translations: {
        en: {
            title: 'Property Selection',
            preparedFor: 'Prepared for',
            preparedBy: 'Prepared by',
            date: 'Date',
            properties: 'Properties',
            property: 'Property',
            price: 'Price',
            location: 'Location',
            bedrooms: 'Bedrooms',
            bathrooms: 'Bathrooms',
            area: 'Area',
            type: 'Type',
            status: 'Status',
            features: 'Features',
            studio: 'Studio',
            viewListing: 'View listing',
            clientFeedback: 'Client Feedback',
            liked: 'Liked',
            passed: 'Passed',
            pending: 'Not Reviewed',
            likeRate: 'Like Rate',
            totalProperties: 'Total Properties',
            reviewed: 'Reviewed',
            generatedBy: 'Generated by Cyprus Real Estate',
            page: 'Page',
            of: 'of',
            bed: 'bed',
            sqm: 'sqm',
            noImage: 'No image',
            licenseNumber: 'License No.',
            realEstateBroker: 'Real Estate Broker',
            propertyId: 'Property ID',
            mapLocation: 'Location Map',
            viewOnMap: 'View on Google Maps',
            coordinates: 'Coordinates',
            photos: 'Photos'
        },
        ru: {
            title: '–ü–æ–¥–±–æ—Ä–∫–∞ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏',
            preparedFor: '–ü–æ–¥–≥–æ—Ç–æ–≤–ª–µ–Ω–æ –¥–ª—è',
            preparedBy: '–ü–æ–¥–≥–æ—Ç–æ–≤–∏–ª',
            date: '–î–∞—Ç–∞',
            properties: '–û–±—ä–µ–∫—Ç—ã',
            property: '–û–±—ä–µ–∫—Ç',
            price: '–¶–µ–Ω–∞',
            location: '–†–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏–µ',
            bedrooms: '–°–ø–∞–ª—å–Ω–∏',
            bathrooms: '–í–∞–Ω–Ω—ã–µ',
            area: '–ü–ª–æ—â–∞–¥—å',
            type: '–¢–∏–ø',
            status: '–°—Ç–∞—Ç—É—Å',
            features: '–û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏',
            studio: '–°—Ç—É–¥–∏—è',
            viewListing: '–û—Ç–∫—Ä—ã—Ç—å –æ–±—ä—è–≤–ª–µ–Ω–∏–µ',
            clientFeedback: '–û—Ç–∑—ã–≤ –∫–ª–∏–µ–Ω—Ç–∞',
            liked: '–ü–æ–Ω—Ä–∞–≤–∏–ª–æ—Å—å',
            passed: '–ü—Ä–æ–ø—É—â–µ–Ω–æ',
            pending: '–ù–µ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–æ',
            likeRate: '–†–µ–π—Ç–∏–Ω–≥',
            totalProperties: '–í—Å–µ–≥–æ –æ–±—ä–µ–∫—Ç–æ–≤',
            reviewed: '–ü—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–æ',
            generatedBy: '–°–æ–∑–¥–∞–Ω–æ Cyprus Real Estate',
            page: '–°—Ç—Ä.',
            of: '–∏–∑',
            bed: '—Å–ø–∞–ª.',
            sqm: '–º¬≤',
            noImage: '–ù–µ—Ç —Ñ–æ—Ç–æ',
            licenseNumber: '–õ–∏—Ü–µ–Ω–∑–∏—è ‚Ññ',
            realEstateBroker: '–ê–≥–µ–Ω—Ç—Å—Ç–≤–æ –Ω–µ–¥–≤–∏–∂–∏–º–æ—Å—Ç–∏',
            propertyId: 'ID –æ–±—ä–µ–∫—Ç–∞',
            mapLocation: '–ö–∞—Ä—Ç–∞ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—è',
            viewOnMap: '–û—Ç–∫—Ä—ã—Ç—å –Ω–∞ –∫–∞—Ä—Ç–∞—Ö Google',
            coordinates: '–ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã',
            photos: '–§–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏'
        },
        el: {
            title: 'ŒïœÄŒπŒªŒøŒ≥ŒÆ ŒëŒ∫ŒπŒΩŒÆœÑœâŒΩ',
            preparedFor: 'Œ†œÅŒøŒµœÑŒøŒπŒºŒ¨œÉœÑŒ∑Œ∫Œµ Œ≥ŒπŒ±',
            preparedBy: 'Œ†œÅŒøŒµœÑŒøŒπŒºŒ¨œÉœÑŒ∑Œ∫Œµ Œ±œÄœå',
            date: 'ŒóŒºŒµœÅŒøŒºŒ∑ŒΩŒØŒ±',
            properties: 'ŒëŒ∫ŒØŒΩŒ∑œÑŒ±',
            property: 'ŒëŒ∫ŒØŒΩŒ∑œÑŒø',
            price: 'Œ§ŒπŒºŒÆ',
            location: 'Œ§ŒøœÄŒøŒ∏ŒµœÉŒØŒ±',
            bedrooms: 'Œ•œÄŒΩŒøŒ¥œâŒºŒ¨œÑŒπŒ±',
            bathrooms: 'ŒúœÄŒ¨ŒΩŒπŒ±',
            area: 'ŒïŒºŒ≤Œ±Œ¥œåŒΩ',
            type: 'Œ§œçœÄŒøœÇ',
            status: 'ŒöŒ±œÑŒ¨œÉœÑŒ±œÉŒ∑',
            features: 'ŒßŒ±œÅŒ±Œ∫œÑŒ∑œÅŒπœÉœÑŒπŒ∫Œ¨',
            studio: 'Œ£œÑŒøœçŒΩœÑŒπŒø',
            viewListing: 'ŒîŒµŒØœÑŒµ Œ±Œ≥Œ≥ŒµŒªŒØŒ±',
            clientFeedback: 'Œ£œáœåŒªŒπŒ± Œ†ŒµŒªŒ¨œÑŒ∑',
            liked: 'ŒëœÅŒ≠œÉŒµŒπ',
            passed: 'Œ†Œ±œÅŒ¨ŒªŒµŒπœàŒ∑',
            pending: 'ŒîŒµŒΩ ŒµŒæŒµœÑŒ¨œÉœÑŒ∑Œ∫Œµ',
            likeRate: 'Œ†ŒøœÉŒøœÉœÑœå',
            totalProperties: 'Œ£œçŒΩŒøŒªŒø Œ±Œ∫ŒπŒΩŒÆœÑœâŒΩ',
            reviewed: 'ŒïŒæŒµœÑŒ¨œÉœÑŒ∑Œ∫Œµ',
            generatedBy: 'ŒîŒ∑ŒºŒπŒøœÖœÅŒ≥ŒÆŒ∏Œ∑Œ∫Œµ Œ±œÄœå Cyprus Real Estate',
            page: 'Œ£ŒµŒª.',
            of: 'Œ±œÄœå',
            bed: 'œÖœÄŒΩ.',
            sqm: 'œÑ.Œº.',
            noImage: 'ŒßœâœÅŒØœÇ ŒµŒπŒ∫œåŒΩŒ±',
            licenseNumber: 'ŒëœÅŒπŒ∏ŒºœåœÇ ŒÜŒ¥ŒµŒπŒ±œÇ',
            realEstateBroker: 'ŒúŒµœÉŒπœÑŒπŒ∫œå ŒìœÅŒ±œÜŒµŒØŒø',
            propertyId: 'ID ŒëŒ∫ŒπŒΩŒÆœÑŒøœÖ',
            mapLocation: 'ŒßŒ¨œÅœÑŒ∑œÇ Œ§ŒøœÄŒøŒ∏ŒµœÉŒØŒ±œÇ',
            viewOnMap: 'Œ†œÅŒøŒ≤ŒøŒªŒÆ œÉœÑŒø Google Maps',
            coordinates: 'Œ£œÖŒΩœÑŒµœÑŒ±Œ≥ŒºŒ≠ŒΩŒµœÇ',
            photos: 'Œ¶œâœÑŒøŒ≥œÅŒ±œÜŒØŒµœÇ'
        }
    },

    // Get translation
    t(key, lang = 'en') {
        return this.translations[lang]?.[key] || this.translations.en[key] || key;
    },

    // Format price from source
    formatPrice(price) {
        if (typeof price === 'number' && price > 0) {
            return '‚Ç¨' + price.toLocaleString();
        }
        if (typeof price === 'string') {
            if (price.includes('‚Ç¨')) return price;
            const num = parseInt(price.replace(/[^\d]/g, ''));
            if (!isNaN(num) && num > 0) {
                return '‚Ç¨' + num.toLocaleString();
            }
        }
        return price || 'N/A';
    },

    // Format date
    formatDate(date, lang = 'en') {
        const d = date ? new Date(date) : new Date();
        const locales = { en: 'en-GB', ru: 'ru-RU', el: 'el-GR' };
        return d.toLocaleDateString(locales[lang] || 'en-GB', {
            day: '2-digit',
            month: 'long',
            year: 'numeric'
        });
    },

    // Load image as base64 with better error handling
    async loadImageAsBase64(url, timeout = 5000) {
        if (!url) return null;
        
        // Skip placeholder images
        if (url.includes('unsplash.com')) return null;

        // Convert Google Drive URLs to direct thumbnail URL
        let imageUrl = url;
        let fileId = null;
        
        if (url.includes('drive.google.com')) {
            if (url.includes('/d/')) {
                fileId = url.split('/d/')[1]?.split('/')[0];
            } else if (url.includes('id=')) {
                fileId = url.split('id=')[1]?.split('&')[0];
            }
            if (fileId) {
                // Check if Google Apps Script proxy is configured
                if (typeof DataSync !== 'undefined' && 
                    DataSync.config?.USE_APPS_SCRIPT_PROXY && 
                    DataSync.config?.GOOGLE_APPS_SCRIPT_URL) {
                    imageUrl = `${DataSync.config.GOOGLE_APPS_SCRIPT_URL}?id=${fileId}`;
                    console.log('üì∏ Using Apps Script proxy for PDF:', fileId);
                } else {
                    // Try lh3.googleusercontent.com format (better CORS support)
                    imageUrl = `https://lh3.googleusercontent.com/d/${fileId}=w400`;
                }
            }
        }

        // Method 1: Try fetch with blob (works for some sources)
        try {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            
            const response = await fetch(imageUrl, { 
                signal: controller.signal,
                mode: 'cors'
            });
            clearTimeout(timeoutId);
            
            if (response.ok) {
                const blob = await response.blob();
                return new Promise((resolve) => {
                    const reader = new FileReader();
                    reader.onloadend = () => resolve(reader.result);
                    reader.onerror = () => resolve(null);
                    reader.readAsDataURL(blob);
                });
            }
        } catch (e) {
            console.log('Fetch method failed, trying canvas method:', e.message);
        }

        // Method 2: Try canvas method (original approach)
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';

            const timeoutId = setTimeout(() => {
                console.log('Image timeout:', imageUrl);
                resolve(null);
            }, timeout);

            img.onload = () => {
                clearTimeout(timeoutId);
                try {
                    const canvas = document.createElement('canvas');
                    const maxWidth = 300;
                    const maxHeight = 220;

                    let width = img.naturalWidth || img.width;
                    let height = img.naturalHeight || img.height;

                    if (width > maxWidth) {
                        height = (maxWidth / width) * height;
                        width = maxWidth;
                    }
                    if (height > maxHeight) {
                        width = (maxHeight / height) * width;
                        height = maxHeight;
                    }

                    canvas.width = width;
                    canvas.height = height;

                    const ctx = canvas.getContext('2d');
                    ctx.fillStyle = '#f5f5f5';
                    ctx.fillRect(0, 0, width, height);
                    ctx.drawImage(img, 0, 0, width, height);

                    resolve(canvas.toDataURL('image/jpeg', 0.85));
                } catch (e) {
                    console.error('Canvas error:', e);
                    resolve(null);
                }
            };

            img.onerror = () => {
                clearTimeout(timeoutId);
                console.log('Image error:', imageUrl);
                resolve(null);
            };

            img.src = imageUrl;
        });
    },

    // Create placeholder image as base64
    createPlaceholderImage(text = 'No image') {
        const canvas = document.createElement('canvas');
        canvas.width = 220;
        canvas.height = 160;
        const ctx = canvas.getContext('2d');

        // Background
        ctx.fillStyle = '#f3f4f6';
        ctx.fillRect(0, 0, 220, 160);
        
        // Border
        ctx.strokeStyle = '#d1d5db';
        ctx.lineWidth = 2;
        ctx.strokeRect(0, 0, 220, 160);

        // Icon (camera/image icon)
        ctx.fillStyle = '#9ca3af';
        ctx.font = 'bold 24px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('üì∑', 110, 70);

        // Text
        ctx.fillStyle = '#6b7280';
        ctx.font = '12px Arial';
        ctx.fillText(text, 110, 100);

        return canvas.toDataURL('image/png');
    },

    // Generate static map image - simple canvas-based map with marker
    async generateStaticMap(lat, lng, zoom = 15, width = 500, height = 300) {
        if (!lat || !lng || isNaN(lat) || isNaN(lng)) {
            return null;
        }

        try {
            // Try Google Maps Static API if key is available
            const googleMapsKey = this.getGoogleMapsKey();
            if (googleMapsKey) {
                console.log('üó∫Ô∏è Using Google Maps Static API');
                const googleMapUrl = `https://maps.googleapis.com/maps/api/staticmap?center=${lat},${lng}&zoom=${zoom}&size=${width}x${height}&scale=2&markers=color:red%7C${lat},${lng}&key=${googleMapsKey}`;
                const googleMapImg = await this.loadImage(googleMapUrl);
                if (googleMapImg) {
                    console.log('‚úÖ Google Maps loaded successfully');
                    return this.addMapOverlay(googleMapImg, lat, lng, width, height);
                } else {
                    console.warn('‚ùå Google Maps failed to load');
                }
            }
            
            // Use OpenStreetMap static map service (same as in property.html)
            console.log('üó∫Ô∏è Using OpenStreetMap static map');
            const osmStaticMap = await this.generateOSMStaticMap(lat, lng, zoom, width, height);
            if (osmStaticMap) {
                console.log('‚úÖ OSM static map loaded');
                return osmStaticMap;
            }
            
            // Final fallback to drawn map
            console.log('üé® Using drawn map (fallback)');
            return this.generateDrawnMap(lat, lng, width, height);
            
        } catch (error) {
            console.error('Error generating static map:', error);
            return this.generateDrawnMap(lat, lng, width, height);
        }
    },

    // Generate static map using OSM Static Map API (WORKING service!)
    async generateOSMStaticMap(lat, lng, zoom, width, height) {
        try {
            // Using staticmap service that works without CORS issues
            // Alternative services:
            // 1. https://staticmap.openstreetmap.de/staticmap.php
            // 2. Custom tile assembly (more complex)
            
            const markerLat = lat;
            const markerLng = lng;
            
            // Using staticmap.openstreetmap.de service (free, no API key needed)
            const osmUrl = `https://staticmap.openstreetmap.de/staticmap.php?center=${lat},${lng}&zoom=${zoom}&size=${width}x${height}&markers=${markerLat},${markerLng},red-pushpin`;
            
            console.log('üîó OSM URL:', osmUrl);
            
            const img = await this.loadImage(osmUrl, 10000); // 10 sec timeout
            
            if (img) {
                // Add our custom overlay with coordinates
                return this.addMapOverlay(img, lat, lng, width, height);
            }
            
            return null;
            
        } catch (error) {
            console.error('OSM static map error:', error);
            return null;
        }
    },

    // Get Google Maps API key from window config or environment
    getGoogleMapsKey() {
        // Check window.GOOGLE_MAPS_API_KEY or return null
        return window.GOOGLE_MAPS_API_KEY || null;
    },

    // Add border and coordinates overlay to Google Maps image
    addMapOverlay(mapImg, lat, lng, width, height) {
        const canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        const ctx = canvas.getContext('2d');
        
        // Draw the map
        ctx.drawImage(mapImg, 0, 0, width, height);
        
        // Add coordinates label
        const coordText = `${lat.toFixed(5)}, ${lng.toFixed(5)}`;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
        ctx.font = 'bold 11px Arial';
        const textWidth = ctx.measureText(coordText).width;
        
        ctx.fillRect(width / 2 - textWidth / 2 - 10, height - 30, textWidth + 20, 22);
        ctx.strokeStyle = '#cbd5e1';
        ctx.lineWidth = 1;
        ctx.strokeRect(width / 2 - textWidth / 2 - 10, height - 30, textWidth + 20, 22);
        
        ctx.fillStyle = '#475569';
        ctx.textAlign = 'center';
        ctx.fillText(coordText, width / 2, height - 14);
        
        // Border
        ctx.strokeStyle = '#94a3b8';
        ctx.lineWidth = 3;
        ctx.strokeRect(0, 0, width, height);
        
        return canvas.toDataURL('image/png');
    },

    // Load real map from OpenStreetMap
    async loadOpenStreetMap(lat, lng, zoom, width, height) {
        try {
            const tileSize = 256;
            const scale = 2; // For retina display
            
            // Calculate tile coordinates
            const x = Math.floor((lng + 180) / 360 * Math.pow(2, zoom));
            const y = Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom));
            
            // Create canvas
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // Calculate how many tiles we need
            const tilesX = Math.ceil(width / tileSize) + 1;
            const tilesY = Math.ceil(height / tileSize) + 1;
            
            // Calculate center offset
            const centerTileX = (lng + 180) / 360 * Math.pow(2, zoom);
            const centerTileY = (1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom);
            
            const offsetX = (centerTileX - Math.floor(centerTileX)) * tileSize;
            const offsetY = (centerTileY - Math.floor(centerTileY)) * tileSize;
            
            const startX = Math.floor(centerTileX) - Math.floor(tilesX / 2);
            const startY = Math.floor(centerTileY) - Math.floor(tilesY / 2);
            
            // Load tiles
            const tilePromises = [];
            for (let dx = 0; dx < tilesX; dx++) {
                for (let dy = 0; dy < tilesY; dy++) {
                    const tileX = startX + dx;
                    const tileY = startY + dy;
                    
                    // OSM tile URL
                    const tileUrl = `https://tile.openstreetmap.org/${zoom}/${tileX}/${tileY}.png`;
                    
                    tilePromises.push(
                        this.loadImage(tileUrl).then(img => ({
                            img,
                            x: dx * tileSize - offsetX + (width - tilesX * tileSize) / 2,
                            y: dy * tileSize - offsetY + (height - tilesY * tileSize) / 2
                        }))
                    );
                }
            }
            
            // Wait for all tiles to load
            const tiles = await Promise.all(tilePromises);
            
            // Draw tiles on canvas
            tiles.forEach(tile => {
                if (tile.img) {
                    ctx.drawImage(tile.img, tile.x, tile.y, tileSize, tileSize);
                }
            });
            
            // Draw location marker
            this.drawMarker(ctx, width / 2, height / 2);
            
            // Add coordinates label
            const coordText = `${lat.toFixed(5)}, ${lng.toFixed(5)}`;
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.font = 'bold 11px Arial';
            const textWidth = ctx.measureText(coordText).width;
            
            // Background for coordinates
            ctx.fillRect(width / 2 - textWidth / 2 - 10, height - 30, textWidth + 20, 22);
            
            // Border
            ctx.strokeStyle = '#cbd5e1';
            ctx.lineWidth = 1;
            ctx.strokeRect(width / 2 - textWidth / 2 - 10, height - 30, textWidth + 20, 22);
            
            // Text
            ctx.fillStyle = '#475569';
            ctx.textAlign = 'center';
            ctx.fillText(coordText, width / 2, height - 14);
            
            // Border around entire map
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 3;
            ctx.strokeRect(0, 0, width, height);
            
            return canvas.toDataURL('image/png');
            
        } catch (error) {
            console.error('Failed to load OSM tiles:', error);
            return null;
        }
    },

    // Helper to load image
    loadImage(url, timeout = 3000) {
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => resolve(img);
            img.onerror = () => {
                console.warn(`Failed to load image: ${url}`);
                resolve(null);
            };
            img.src = url;
            
            // Timeout
            setTimeout(() => {
                console.warn(`Image load timeout: ${url}`);
                resolve(null);
            }, timeout);
        });
    },

    // Draw location marker on canvas
    drawMarker(ctx, x, y) {
        // Marker shadow
        ctx.beginPath();
        ctx.ellipse(x, y + 25, 14, 5, 0, 0, 2 * Math.PI);
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.fill();
        
        // Marker pin
        ctx.beginPath();
        ctx.moveTo(x, y + 20);
        ctx.bezierCurveTo(x - 20, y, x - 20, y - 28, x, y - 35);
        ctx.bezierCurveTo(x + 20, y - 28, x + 20, y, x, y + 20);
        
        // Gradient for pin
        const pinGradient = ctx.createLinearGradient(x - 20, y - 35, x + 20, y + 20);
        pinGradient.addColorStop(0, '#ef4444');
        pinGradient.addColorStop(1, '#dc2626');
        ctx.fillStyle = pinGradient;
        ctx.fill();
        
        // Pin border
        ctx.strokeStyle = '#991b1b';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Inner white circle
        ctx.beginPath();
        ctx.arc(x, y - 15, 8, 0, 2 * Math.PI);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        ctx.strokeStyle = '#dc2626';
        ctx.lineWidth = 2;
        ctx.stroke();
    },

    // Fallback: generate drawn map (previous implementation improved)
    generateDrawnMap(lat, lng, width, height) {
        console.log(`üé® [REALISTIC] Generating map for: ${lat}, ${lng}, size: ${width}x${height}`);
        
        try {
            const canvas = document.createElement('canvas');
            if (!canvas) {
                console.error('‚ùå Cannot create canvas');
                return null;
            }
            
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            if (!ctx) {
                console.error('‚ùå Cannot get 2d context');
                return null;
            }
            
            console.log('‚úÖ Canvas created successfully');
            
            // More realistic OSM-like background
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#f2efe9');
            gradient.addColorStop(1, '#e8e4d8');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Add "green spaces" (parks)
            ctx.fillStyle = '#d4e7c5';
            for (let i = 0; i < 8; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const size = 30 + Math.random() * 50;
                ctx.fillRect(x, y, size, size);
            }
            
            // Add "water" areas  
            ctx.fillStyle = '#aad3df';
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                const x = Math.random() * width;
                const y = Math.random() * height;
                const radius = 25 + Math.random() * 40;
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Major roads (yellow/orange like OSM)
            ctx.strokeStyle = '#fcd6a4';
            ctx.lineWidth = 8;
            for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                const startX = Math.random() * width;
                const startY = Math.random() * height;
                ctx.moveTo(startX, 0);
                ctx.lineTo(startX + (Math.random() - 0.5) * 100, height);
                ctx.stroke();
            }
            
            // Minor roads (white like OSM)
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            for (let x = 0; x < width; x += 70) {
                ctx.beginPath();
                ctx.moveTo(x + (Math.random() - 0.5) * 20, 0);
                ctx.lineTo(x + (Math.random() - 0.5) * 20, height);
                ctx.stroke();
            }
            for (let y = 0; y < height; y += 70) {
                ctx.beginPath();
                ctx.moveTo(0, y + (Math.random() - 0.5) * 20);
                ctx.lineTo(width, y + (Math.random() - 0.5) * 20);
                ctx.stroke();
            }
            
            // Small streets (light gray)
            ctx.strokeStyle = '#f0f0f0';
            ctx.lineWidth = 2;
            for (let x = 35; x < width; x += 70) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            for (let y = 35; y < height; y += 70) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // "Buildings" (small rectangles)
            ctx.fillStyle = '#e8e4d8';
            ctx.strokeStyle = '#c0b8a8';
            ctx.lineWidth = 1;
            for (let i = 0; i < 40; i++) {
                const bx = Math.random() * width;
                const by = Math.random() * height;
                const bw = 10 + Math.random() * 20;
                const bh = 10 + Math.random() * 20;
                ctx.fillRect(bx, by, bw, bh);
                ctx.strokeRect(bx, by, bw, bh);
            }
            
            // Center position
            const cx = width / 2;
            const cy = height / 2;
            
            // Red marker pin - OSM style
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.ellipse(cx, cy + 28, 14, 5, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Pin body (larger, more prominent)
            ctx.beginPath();
            ctx.moveTo(cx, cy + 20);
            ctx.bezierCurveTo(cx - 18, cy + 5, cx - 18, cy - 15, cx, cy - 25);
            ctx.bezierCurveTo(cx + 18, cy - 15, cx + 18, cy + 5, cx, cy + 20);
            
            const pinGradient = ctx.createRadialGradient(cx - 5, cy - 10, 5, cx, cy, 25);
            pinGradient.addColorStop(0, '#ff5555');
            pinGradient.addColorStop(1, '#cc0000');
            ctx.fillStyle = pinGradient;
            ctx.fill();
            
            ctx.strokeStyle = '#8b0000';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // White center dot
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(cx, cy - 8, 6, 0, Math.PI * 2);
            ctx.fill();
            
            // Coordinates text - OSM style
            const coordText = `${parseFloat(lat).toFixed(5)}, ${parseFloat(lng).toFixed(5)}`;
            ctx.font = 'bold 11px Arial, sans-serif';
            
            // Background box
            const textMetrics = ctx.measureText(coordText);
            const boxWidth = textMetrics.width + 16;
            const boxHeight = 22;
            const boxX = cx - boxWidth / 2;
            const boxY = height - 35;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 1;
            ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
            
            // Text
            ctx.fillStyle = '#333333';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(coordText, cx, boxY + boxHeight / 2);
            
            // Border around map
            ctx.strokeStyle = '#cccccc';
            ctx.lineWidth = 2;
            ctx.strokeRect(0, 0, width, height);
            
            // "OpenStreetMap style" watermark (subtle)
            ctx.font = '8px Arial';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.textAlign = 'right';
            ctx.fillText('Map data ¬© OpenStreetMap contributors', width - 5, height - 5);
            
            const dataUrl = canvas.toDataURL('image/png');
            console.log(`‚úÖ Realistic map generated successfully! Length: ${dataUrl.length} chars`);
            
            return dataUrl;
            
        } catch (error) {
            console.error('‚ùå Error in generateDrawnMap:', error);
            console.error('Stack:', error.stack);
            return null;
        }
    },

    // Get Google Maps URL
    getGoogleMapsUrl(lat, lng) {
        if (!lat || !lng || isNaN(lat) || isNaN(lng)) return null;
        return `https://www.google.com/maps?q=${lat},${lng}`;
    },

    // Show loading overlay
    showLoading(message = 'Generating PDF...') {
        const existing = document.getElementById('pdfLoading');
        if (existing) existing.remove();

        const loadingDiv = document.createElement('div');
        loadingDiv.id = 'pdfLoading';
        loadingDiv.style.cssText = `
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 99999;
        `;
        loadingDiv.innerHTML = `
            <div style="background: white; padding: 30px 50px; border-radius: 12px; text-align: center; box-shadow: 0 10px 40px rgba(0,0,0,0.3);">
                <div style="width: 50px; height: 50px; border: 4px solid #e5e7eb; border-top-color: #6366f1; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
                <p style="margin: 0; font-size: 16px; font-weight: 500;" id="pdfLoadingText">${message}</p>
                <p style="margin: 10px 0 0; font-size: 12px; color: #888;" id="pdfLoadingSubtext">Please wait...</p>
            </div>
            <style>
                @keyframes spin {
                    to { transform: rotate(360deg); }
                }
            </style>
        `;
        document.body.appendChild(loadingDiv);
    },

    // Update loading text
    updateLoading(text, subtext = '') {
        const textEl = document.getElementById('pdfLoadingText');
        const subtextEl = document.getElementById('pdfLoadingSubtext');
        if (textEl) textEl.textContent = text;
        if (subtextEl) subtextEl.textContent = subtext;
    },

    // Hide loading overlay
    hideLoading() {
        document.getElementById('pdfLoading')?.remove();
    },

    // Generate PDF for a selection (before client reviews)
    async generateSelectionPDF(options) {
        const {
            selectionName,
            clientName,
            brokerName = 'Cyprus Real Estate',
            properties,
            lang = 'en'
        } = options;

        if (typeof pdfMake === 'undefined') {
            alert('PDF library not loaded. Please refresh the page.');
            return;
        }

        this.showLoading(this.t('title', lang));
        this.updateLoading('Loading images...', `0 / ${properties.length}`);

        try {
            // Pre-load all images with timeout
            const placeholderImg = this.createPlaceholderImage(this.t('noImage', lang));
            
            const imagePromises = properties.map(async (prop, idx) => {
                try {
                    // Load main photo
                    const mainImg = await Promise.race([
                        this.loadImageAsBase64(prop.photos?.[0]),
                        new Promise((resolve) => setTimeout(() => resolve(null), 5000))
                    ]);
                    
                    // Load up to 3 additional photos
                    const additionalPhotos = [];
                    const photosToLoad = (prop.photos || []).slice(1, 4); // Get photos 1-3
                    
                    for (const photoUrl of photosToLoad) {
                        const photo = await Promise.race([
                            this.loadImageAsBase64(photoUrl),
                            new Promise((resolve) => setTimeout(() => resolve(null), 3000))
                        ]);
                        if (photo) {
                            additionalPhotos.push(photo);
                        }
                    }
                    
                    // Generate map if coordinates available
                    let mapImg = null;
                    console.log(`üó∫Ô∏è Checking property ${prop.id || prop.title}:`, {
                        hasLatitude: !!prop.latitude,
                        hasLongitude: !!prop.longitude,
                        latValue: prop.latitude,
                        lngValue: prop.longitude,
                        latValid: !isNaN(prop.latitude),
                        lngValid: !isNaN(prop.longitude)
                    });
                    
                    if (prop.latitude && prop.longitude && !isNaN(prop.latitude) && !isNaN(prop.longitude)) {
                        console.log(`‚úÖ Coordinates valid for ${prop.id}, generating map...`);
                        try {
                            mapImg = await this.generateStaticMap(prop.latitude, prop.longitude, 16, 400, 240);
                            console.log(`üìç Map result for ${prop.id}:`, mapImg ? `SUCCESS (${mapImg.substring(0, 50)}...)` : 'NULL');
                        } catch (mapError) {
                            console.error('‚ùå Map generation error for', prop.id, mapError);
                            console.log('üîÑ Trying direct fallback to drawn map...');
                            // Force fallback to drawn map
                            mapImg = this.generateDrawnMap(prop.latitude, prop.longitude, 500, 300);
                            console.log('üîÑ Fallback result:', mapImg ? 'SUCCESS' : 'FAILED');
                        }
                    } else {
                        console.warn(`‚ö†Ô∏è Skipping map for ${prop.id} - invalid coordinates`);
                    }
                    
                    this.updateLoading('Loading images...', `${idx + 1} / ${properties.length}`);
                    
                    return { 
                        prop, 
                        mainImg: mainImg || placeholderImg,
                        additionalPhotos,
                        mapImg,
                        googleMapsUrl: this.getGoogleMapsUrl(prop.latitude, prop.longitude)
                    };
                } catch (error) {
                    console.error('Error loading images for property:', prop.id, error);
                    this.updateLoading('Loading images...', `${idx + 1} / ${properties.length}`);
                    return { 
                        prop, 
                        mainImg: placeholderImg,
                        additionalPhotos: [],
                        mapImg: null,
                        googleMapsUrl: null
                    };
                }
            });

            // Wait for all images with overall timeout (30 seconds max)
            const propertiesWithImages = await Promise.race([
                Promise.all(imagePromises),
                new Promise((resolve) => {
                    setTimeout(() => {
                        console.log('Image loading timeout - using placeholders for remaining images');
                        resolve(properties.map(prop => ({ 
                            prop, 
                            mainImg: placeholderImg,
                            additionalPhotos: [],
                            mapImg: null,
                            googleMapsUrl: null
                        })));
                    }, 30000); // 30 seconds max total
                })
            ]);

            this.updateLoading('Generating PDF...', '');

            // Build document content
            const content = [];

            // Header
            content.push({
                text: this.t('title', lang),
                style: 'header',
                margin: [0, 0, 0, 5]
            });

            content.push({
                text: `${properties.length} ${this.t('properties', lang).toLowerCase()}`,
                style: 'subheader',
                margin: [0, 0, 0, 20]
            });

            // Info section
            if (clientName) {
                content.push({
                    text: `${this.t('preparedFor', lang)}: ${clientName}`,
                    style: 'info'
                });
            }
            content.push({
                text: `${this.t('preparedBy', lang)}: ${brokerName}`,
                style: 'info'
            });
            content.push({
                text: `${this.t('date', lang)}: ${this.formatDate(null, lang)}`,
                style: 'info',
                margin: [0, 0, 0, 10]
            });

            if (selectionName) {
                content.push({
                    text: selectionName,
                    style: 'selectionName',
                    margin: [0, 0, 0, 20]
                });
            }

            // Properties
            propertiesWithImages.forEach(({ prop, mainImg, additionalPhotos, mapImg, googleMapsUrl }, index) => {
                const bedText = prop.bedrooms === 0 ? this.t('studio', lang) : `${prop.bedrooms} ${this.t('bed', lang)}`;
                const areaText = prop.area ? `${prop.area} ${this.t('sqm', lang)}` : '';
                const stats = [bedText, areaText, prop.type].filter(Boolean).join(' ‚Ä¢ ');

                // Main property card with photo
                const propertyTable = {
                    table: {
                        widths: [120, '*'],
                        body: [[
                            // Image column
                            {
                                image: mainImg,
                                width: 110,
                                height: 80,
                                margin: [0, 5, 0, 5]
                            },
                            // Details column
                            {
                                stack: [
                                    {
                                        columns: [
                                            {
                                                text: `${index + 1}. ${prop.id || 'Property'}`,
                                                style: 'propertyTitle',
                                                width: '*'
                                            },
                                            {
                                                text: prop.price || (prop.cleanPrice > 0 ? this.formatPrice(prop.cleanPrice) : 'Price on request'),
                                                style: 'propertyPrice',
                                                width: 'auto',
                                                alignment: 'right'
                                            }
                                        ]
                                    },
                                    {
                                        text: (prop.title || '').substring(0, 60),
                                        style: 'propertyStats',
                                        margin: [0, 2, 0, 0]
                                    },
                                    {
                                        text: prop.location || 'Cyprus',
                                        style: 'propertyLocation',
                                        margin: [0, 3, 0, 0]
                                    },
                                    {
                                        text: stats,
                                        style: 'propertyStats',
                                        margin: [0, 3, 0, 0]
                                    }
                                ],
                                margin: [10, 5, 5, 5]
                            }
                        ]]
                    },
                    layout: {
                        hLineWidth: () => 1,
                        vLineWidth: () => 1,
                        hLineColor: () => '#e5e7eb',
                        vLineColor: () => '#e5e7eb',
                        paddingLeft: () => 5,
                        paddingRight: () => 5,
                        paddingTop: () => 5,
                        paddingBottom: () => 5
                    },
                    margin: [0, 0, 0, 10]
                };

                content.push(propertyTable);

                // Additional photos section (if available)
                if (additionalPhotos && additionalPhotos.length > 0) {
                    const photoColumns = [];
                    additionalPhotos.forEach(photo => {
                        photoColumns.push({
                            image: photo,
                            width: additionalPhotos.length === 1 ? 150 : (additionalPhotos.length === 2 ? 120 : 100),
                            margin: [0, 0, 5, 0]
                        });
                    });

                    content.push({
                        columns: photoColumns,
                        margin: [0, 0, 0, 10]
                    });
                }

                // Map section (if coordinates available)
                if (mapImg || googleMapsUrl) {
                    console.log(`üìç Adding map to PDF for property ${index + 1}, mapImg:`, mapImg ? 'EXISTS' : 'NULL');
                    const mapContent = [];
                    
                    mapContent.push({
                        text: `üìç ${this.t('mapLocation', lang)}`,
                        style: 'mapTitle',
                        margin: [0, 10, 0, 8]
                    });

                    if (mapImg) {
                        console.log(`‚úÖ Inserting map image into PDF (${mapImg.substring(0, 50)}...)`);
                        mapContent.push({
                            image: mapImg,
                            width: 400,
                            margin: [0, 0, 0, 10]
                        });
                    } else {
                        console.warn(`‚ö†Ô∏è No map image available for property ${index + 1}`);
                    }

                    if (googleMapsUrl) {
                        mapContent.push({
                            text: this.t('viewOnMap', lang),
                            link: googleMapsUrl,
                            style: 'mapLink',
                            margin: [0, 0, 0, 5]
                        });
                    }

                    if (prop.latitude && prop.longitude) {
                        mapContent.push({
                            text: `${this.t('coordinates', lang)}: ${prop.latitude.toFixed(5)}, ${prop.longitude.toFixed(5)}`,
                            style: 'coordinates',
                            margin: [0, 2, 0, 0]
                        });
                    }

                    content.push({
                        stack: mapContent,
                        margin: [0, 0, 0, 15]
                    });
                }

                // Separator between properties (except last one)
                if (index < propertiesWithImages.length - 1) {
                    content.push({
                        canvas: [{
                            type: 'line',
                            x1: 0, y1: 0,
                            x2: 515, y2: 0,
                            lineWidth: 1,
                            lineColor: '#e5e7eb'
                        }],
                        margin: [0, 10, 0, 15]
                    });
                }
            });

            // Document definition
            const docDefinition = {
                content: content,
                styles: {
                    header: {
                        fontSize: 22,
                        bold: true,
                        color: '#1e1b4b'
                    },
                    subheader: {
                        fontSize: 12,
                        color: '#6b7280'
                    },
                    info: {
                        fontSize: 10,
                        color: '#6b7280',
                        margin: [0, 2, 0, 2]
                    },
                    selectionName: {
                        fontSize: 14,
                        bold: true,
                        color: '#1e1b4b'
                    },
                    propertyTitle: {
                        fontSize: 11,
                        bold: true,
                        color: '#1f2937'
                    },
                    propertyPrice: {
                        fontSize: 12,
                        bold: true,
                        color: '#6366f1'
                    },
                    propertyLocation: {
                        fontSize: 9,
                        color: '#6b7280'
                    },
                    propertyStats: {
                        fontSize: 9,
                        color: '#9ca3af'
                    },
                    propertyLink: {
                        fontSize: 8,
                        color: '#6366f1'
                    },
                    mapTitle: {
                        fontSize: 10,
                        bold: true,
                        color: '#374151'
                    },
                    mapLink: {
                        fontSize: 8,
                        color: '#6366f1',
                        decoration: 'underline'
                    },
                    coordinates: {
                        fontSize: 7,
                        color: '#9ca3af',
                        italics: true
                    }
                },
                defaultStyle: {
                    font: 'Roboto'
                },
                footer: (currentPage, pageCount) => ({
                    columns: [
                        {
                            text: this.t('generatedBy', lang),
                            alignment: 'left',
                            fontSize: 8,
                            color: '#9ca3af',
                            margin: [40, 0, 0, 0]
                        },
                        {
                            text: `${this.t('page', lang)} ${currentPage} ${this.t('of', lang)} ${pageCount}`,
                            alignment: 'right',
                            fontSize: 8,
                            color: '#9ca3af',
                            margin: [0, 0, 40, 0]
                        }
                    ],
                    margin: [0, 10, 0, 0]
                }),
                pageMargins: [40, 40, 40, 50]
            };

            // Generate and download
            const fileName = `${(selectionName || 'Selection').replace(/[^a-zA-Z0-9–∞-—è–ê-–Ø—ë–ÅŒ±-œâŒë-Œ©\s]/g, '_')}_${lang.toUpperCase()}.pdf`;
            pdfMake.createPdf(docDefinition).download(fileName);

            this.hideLoading();
            return fileName;

        } catch (error) {
            console.error('PDF generation failed:', error);
            this.hideLoading();
            alert('Failed to generate PDF: ' + error.message);
        }
    },

    // Generate PDF with client reactions
    async generateResultsPDF(options) {
        const {
            selectionName,
            clientName,
            brokerName = 'Cyprus Real Estate',
            brokerLicense = '1234/E',
            brokerLogo = null,
            properties,
            reactions,
            lang = 'en',
            showForBroker = false
        } = options;

        if (typeof pdfMake === 'undefined') {
            alert('PDF library not loaded. Please refresh the page.');
            return;
        }

        this.showLoading(this.t('clientFeedback', lang));
        this.updateLoading('Generating PDF...', '');

        try {
            const liked = reactions.filter(r => r.reaction === 'like');
            const disliked = reactions.filter(r => r.reaction === 'dislike');
            const likeRate = reactions.length > 0 ? Math.round((liked.length / reactions.length) * 100) : 0;

            // Build document content
            const content = [];

            // Header with branding
            const headerRow = [];
            
            // Logo (if provided)
            if (brokerLogo) {
                headerRow.push({
                    image: brokerLogo,
                    width: 60,
                    margin: [0, 0, 15, 0]
                });
            }
            
            // Company info
            headerRow.push({
                stack: [
                    {
                        text: brokerName,
                        style: 'header',
                        margin: [0, 0, 0, 5]
                    },
                    {
                        text: `${this.t('realEstateBroker', lang)}`,
                        style: 'subheader',
                        margin: [0, 0, 0, 2]
                    },
                    {
                        text: `${this.t('licenseNumber', lang)} ${brokerLicense}`,
                        style: 'info',
                        color: '#6366f1',
                        bold: true
                    }
                ],
                width: '*'
            });
            
            content.push({
                columns: headerRow,
                margin: [0, 0, 0, 15]
            });
            
            content.push({
                canvas: [
                    {
                        type: 'line',
                        x1: 0, y1: 0,
                        x2: 515, y2: 0,
                        lineWidth: 2,
                        lineColor: '#6366f1'
                    }
                ],
                margin: [0, 0, 0, 20]
            });

            // Title
            content.push({
                text: this.t('clientFeedback', lang),
                style: 'header',
                margin: [0, 0, 0, 5]
            });

            content.push({
                text: selectionName || this.t('title', lang),
                style: 'subheader',
                margin: [0, 0, 0, 20]
            });

            // Info section
            if (clientName) {
                content.push({
                    text: `${this.t('preparedFor', lang)}: ${clientName}`,
                    style: 'info'
                });
            }
            content.push({
                text: `${this.t('date', lang)}: ${this.formatDate(null, lang)}`,
                style: 'info',
                margin: [0, 0, 0, 15]
            });

            // Summary stats
            content.push({
                table: {
                    widths: ['*', '*', '*', '*'],
                    body: [[
                        {
                            stack: [
                                { text: properties.length.toString(), style: 'statValue' },
                                { text: this.t('totalProperties', lang), style: 'statLabel' }
                            ],
                            alignment: 'center',
                            margin: [0, 10, 0, 10]
                        },
                        {
                            stack: [
                                { text: liked.length.toString(), style: 'statValueGreen' },
                                { text: this.t('liked', lang), style: 'statLabel' }
                            ],
                            alignment: 'center',
                            margin: [0, 10, 0, 10]
                        },
                        {
                            stack: [
                                { text: disliked.length.toString(), style: 'statValueRed' },
                                { text: this.t('passed', lang), style: 'statLabel' }
                            ],
                            alignment: 'center',
                            margin: [0, 10, 0, 10]
                        },
                        {
                            stack: [
                                { text: `${likeRate}%`, style: 'statValue' },
                                { text: this.t('likeRate', lang), style: 'statLabel' }
                            ],
                            alignment: 'center',
                            margin: [0, 10, 0, 10]
                        }
                    ]]
                },
                layout: {
                    hLineWidth: () => 1,
                    vLineWidth: () => 1,
                    hLineColor: () => '#e5e7eb',
                    vLineColor: () => '#e5e7eb'
                },
                margin: [0, 0, 0, 25]
            });

            // Liked section
            if (liked.length > 0) {
                content.push({
                    text: [
                        { text: '‚ù§ ', style: 'sectionIconGreen' },
                        { text: `${this.t('liked', lang)} (${liked.length})`, style: 'sectionTitle' }
                    ],
                    margin: [0, 0, 0, 10]
                });

                liked.forEach(reaction => {
                    const prop = properties.find(p => p.id === reaction.property_id) || {};
                    content.push(this.createReactionRow(reaction, prop, 'like', lang, showForBroker));
                });

                content.push({ text: '', margin: [0, 0, 0, 15] });
            }

            // Passed section
            if (disliked.length > 0) {
                content.push({
                    text: [
                        { text: '‚úï ', style: 'sectionIconRed' },
                        { text: `${this.t('passed', lang)} (${disliked.length})`, style: 'sectionTitle' }
                    ],
                    margin: [0, 0, 0, 10]
                });

                disliked.forEach(reaction => {
                    const prop = properties.find(p => p.id === reaction.property_id) || {};
                    content.push(this.createReactionRow(reaction, prop, 'dislike', lang, showForBroker));
                });
            }

            // Document definition
            const docDefinition = {
                content: content,
                styles: {
                    header: {
                        fontSize: 20,
                        bold: true,
                        color: '#1e1b4b'
                    },
                    subheader: {
                        fontSize: 12,
                        color: '#6b7280'
                    },
                    info: {
                        fontSize: 10,
                        color: '#6b7280',
                        margin: [0, 2, 0, 2]
                    },
                    statValue: {
                        fontSize: 18,
                        bold: true,
                        color: '#1f2937'
                    },
                    statValueGreen: {
                        fontSize: 18,
                        bold: true,
                        color: '#10b981'
                    },
                    statValueRed: {
                        fontSize: 18,
                        bold: true,
                        color: '#ef4444'
                    },
                    statLabel: {
                        fontSize: 9,
                        color: '#6b7280'
                    },
                    sectionTitle: {
                        fontSize: 13,
                        bold: true,
                        color: '#1f2937'
                    },
                    sectionIconGreen: {
                        fontSize: 13,
                        color: '#10b981'
                    },
                    sectionIconRed: {
                        fontSize: 13,
                        color: '#ef4444'
                    },
                    reactionTitle: {
                        fontSize: 10,
                        bold: true,
                        color: '#1f2937'
                    },
                    reactionPrice: {
                        fontSize: 10,
                        bold: true,
                        color: '#6366f1'
                    },
                    reactionPriceVAT: {
                        fontSize: 9,
                        bold: true,
                        color: '#10b981'
                    },
                    reactionDetails: {
                        fontSize: 8,
                        color: '#6b7280'
                    },
                    reactionLink: {
                        fontSize: 8,
                        color: '#6366f1'
                    }
                },
                defaultStyle: {
                    font: 'Roboto'
                },
                footer: (currentPage, pageCount) => ({
                    columns: [
                        {
                            text: this.t('generatedBy', lang),
                            alignment: 'left',
                            fontSize: 8,
                            color: '#9ca3af',
                            margin: [40, 0, 0, 0]
                        },
                        {
                            text: `${this.t('page', lang)} ${currentPage} ${this.t('of', lang)} ${pageCount}`,
                            alignment: 'right',
                            fontSize: 8,
                            color: '#9ca3af',
                            margin: [0, 0, 40, 0]
                        }
                    ],
                    margin: [0, 10, 0, 0]
                }),
                pageMargins: [40, 40, 40, 50]
            };

            // Generate and download
            const fileName = `${(selectionName || 'Results').replace(/[^a-zA-Z0-9–∞-—è–ê-–Ø—ë–ÅŒ±-œâŒë-Œ©\s]/g, '_')}_${this.t('clientFeedback', lang)}_${lang.toUpperCase()}.pdf`;
            pdfMake.createPdf(docDefinition).download(fileName);

            this.hideLoading();
            return fileName;

        } catch (error) {
            console.error('PDF generation failed:', error);
            this.hideLoading();
            alert('Failed to generate PDF: ' + error.message);
        }
    },

    // Create a reaction row for results PDF
    createReactionRow(reaction, prop, type, lang, showForBroker = false) {
        const isLike = type === 'like';
        const borderColor = isLike ? '#10b981' : '#ef4444';
        const icon = isLike ? '‚ù§' : '‚úï';

        const bedText = prop.bedrooms === 0 ? this.t('studio', lang) : `${prop.bedrooms} ${this.t('bed', lang)}`;
        const details = `${prop.location || 'Cyprus'} ‚Ä¢ ${bedText} ‚Ä¢ ${prop.area || '-'} ${this.t('sqm', lang)}`;

        // Get price from source
        const price = prop.price || 'Price on request';

        // Build price stack
        const priceStack = [
            {
                text: price,
                style: 'reactionPrice',
                alignment: 'right'
            }
        ];

        // Add property ID for broker
        if (showForBroker && prop.id) {
            priceStack.push({
                text: `${this.t('propertyId', lang)}: ${prop.id}`,
                style: 'reactionDetails',
                alignment: 'right',
                color: '#9ca3af',
                margin: [0, 3, 0, 0]
            });
        }


        const row = {
            table: {
                widths: [3, '*', 'auto'],
                body: [[
                    // Accent bar
                    { text: '', fillColor: borderColor },
                    // Main content
                    {
                        stack: [
                            {
                                text: [
                                    { text: icon + ' ', color: borderColor },
                                    { text: prop.id || 'Property', style: 'reactionTitle' }
                                ]
                            },
                            {
                                text: (reaction.property_title || prop.title || '').substring(0, 60),
                                style: 'reactionDetails',
                                margin: [0, 2, 0, 0]
                            },
                            {
                                text: details,
                                style: 'reactionDetails',
                                margin: [0, 3, 0, 0]
                            }
                        ],
                        margin: [8, 5, 5, 5]
                    },
                    // Price and info
                    {
                        stack: priceStack,
                        margin: [5, 5, 8, 5]
                    }
                ]]
            },
            layout: {
                hLineWidth: () => 1,
                vLineWidth: (i) => i === 0 ? 0 : 1,
                hLineColor: () => '#e5e7eb',
                vLineColor: () => '#e5e7eb',
                paddingLeft: () => 0,
                paddingRight: () => 0,
                paddingTop: () => 0,
                paddingBottom: () => 0
            },
            margin: [0, 0, 0, 8]
        };

        return row;
    },

    // Convert external URL to internal format
};

// Export
if (typeof window !== 'undefined') {
    window.PDFExport = PDFExport;
}
